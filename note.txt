- dùng React 17.0.2
- dùng CDN <script crossorigin src="https://unpkg.com/react@17/umd/react.development.js"></script> dể dùng React không cần tải từ npm
- nếu dùng React CDN thì dùng console.log ra để thấy được các thuộc tính của React
    + React.version để kiểm tra phiên bản React Đang dùng
- React.createElement dùng để tạo 1 element, giống document.createElement
- React.createElement(type, props, child, child n,...);
- React.createElement(<element>, {<các thuộc tính của element>}, '<text node>');
    ex: const h1React = React.createElement('h1', {
        titile: 'hello',
        className: 'heading',
    }, 'hello React')   
    --> nếu muốn render ra phải dùng react-dom 

-> React.createElement thực tế không dùng, này để học cho biết. dùng JSX dễ hơn
- dùng ReactDOM 17.0.2
- dùng CDN <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script> để dùng ReactDOM, ReactDOM dùng để render các element
- ReactDOM.render(element, container, callback). Hiện tại chưa dùng đến tham số callback
- dùng babel <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
- dùng thư viện babel để code JSX. không dùng React.createElement dài dòng nữa
- JSX có thể viết JS trong HTML, dùng dấu '{}'. Thêm type="text/babel" ở thẻ mở script trình duyệt nó mới nhận babel
    --> nếu không dùng type="text/babel" thì sẽ không code được JSX
- thuộc tính style trong JSX là 1 object
    + <p style={{color: 'red'}}>Hello</p>
- <React.Fragment>...</React.Fragment> viết được nhiều block element
- dùng function/class để chia component
- dùng props(props có kiểu dữ liệu là object) có thể truyền được tất cả kiểu dữ liệu, dùng kết hợp với destructuring
- tên các DOM event trong React là camelCase: onClick, onChange,...
- tên component đặt kiểu PascalCase, nếu không sẽ bị lỗi
- children props: là thuộc tính của props, children là nội dung bên trong 1 component
- dùng nodeJS chứ không dùng CDN link nữa
- npx create-react-app <tên project>: tạo project với ReactJS
- mặc định là React18 nên mình phải hạ xuống React17 (https://dev.to/ifeanyichima/how-to-downgrade-from-react-18-to-1702-818) để code theo F8 không bị lỗi
- npm start: chạy project trên trình duyệt
- các file trong folder public ở trình duyệt mới truy cập được, còn lại ở trình duyệt không truy cập được(bảo mật), khi React chạy thì file index.html trong folder public sẽ được chạy
- Hook chỉ được dùng trong function component, không dùng "this" như trong class component
- useState(): là các giá trị được lưu trữ trong component giá trị thay đổi thì giao diện sẽ thay đổi và component đó sẽ được re-render lại
    + syntax: const [state, setState] = useState(initState);
        - setState mới sẽ ghi đè state cũ, dùng kết hợp với spead để thêm state mà không bị ghi đè state cũ
        - initState bất cứ kiểu dữ liệu gì cũng được, nếu initState là 1 hàm thì initState sẽ lấy giá trị của hàm đó retrun về, và các giá trị trong initState chỉ được khởi tạo 1 lần duy nhất khi component render lần đầu
- nên dùng callback có tham số prevState để setState       
- truyền hàm cho các sự kiện:
    ex: function logger(){
            console.log(123);
        }
        JSX: 
        + <button onClick={logger}></button> //kiểu tham chiếu, khi click vào thì hàm mới thực thi
        + <button onClick={logger()}></button> // khi component render thì hàm sẽ thực thi luôn, chưa click mà đã thực thi, cách này sai 
        + <button onClick={() => logger()}></button> //cơ chế giống kiểu tham chiếu, nhưng sẽ truyền được tham số
- tips hay: dùng callback trong setState thì callback sẽ thực hiện sau khi component được re-render lại, React sẽ lên lịch cập nhật state và render lại, sau đó callback được truyền trong setState mới được thực thi sau
- toán tử '??' (Nullish Coalescing Operator) để kiểm tra giá trị bên trái nếu là 'null' hoặc 'undefined' thì code bên phải được chạy và ngược lại
    --> toán tử này được dùng lai lai toán tử 3 ngôi (ternary operator)
- toán tử '&&' là truty, nếu giá trị bên trái khác false, null, undefined, 0, NaN, '<rỗng>' thì code bên phải được chạy và ngược lại
- thuật ngữ "Mount và Unmount" là gắn và gở 1 component, (dùng câu lệnh điều kiện + useState để thực hiện)
- useEffect: cho phép thực hiện các side effect trong component. Side effect là các thao tác bên ngoài component như tương tác với API, đọc/ghi dữ liệu từ DB hoặc thay đổi DOM (https://chat.openai.com/chat/5a13ac2f-c84f-49b2-938e-acea958b5a8d), hàm useEffect có 2 tham số: callback(để thực các side effect), dependency
    1. useEffect chỉ có callback không có tham số dependency (trường hợp này ít dùng vì callback sẽ được gọi lại khi component re-render)
        - gọi callback mỗi khi component re-render 
        - khi state trong component thay đổi thì callback được gọi lại
        - gọi callback sau khi component thêm element vào DOM
    2. useEffect có callback và có dependency là mảng rỗng '[]'
        - chỉ gọi callback 1 lần sau khi component mouted, component có re-render thì callback vẫn không bị gọi lại
    3. useEffect có callback và có dependency '[<biến, state hoặc props,...>]'
        - callback chỉ được gọi khi dependency thay đổi
    --> cả 3 trường hợp: 
        >> callback được gọi sau khi component mouted (là component được render là đầu tiên), 1 useEffect chỉ thực hiện 1 side effect.
        >> cleanup function được gọi trước khi component unmouted (để tránh memory leak). cleanup function là hàm được callback trong useEffect return
        >> cleanup function được gọi trước callback (trừ lúc component Mount là callback sẽ được gọi trước)    
- khi dùng React thì các component thường xuyên Mount và Unmount bởi thao tác của người dùng, khi dùng window event lúc Mount thì event của window được lưu trong bộ nhớ và lúc Unmount thì event đó không bị xoá đi mà vẫn còn nằm trong bộ nhớ, điều này làm rò rỉ bộ nhớ (memory leak). Cách khắc phục là lúc Mount thì addEventListener, lúc Unmount thì removeEventListener. Dùng cleanup function để removeEventListener
- các hàm timer functions:  setInterval, setTimeout. 2 hàm này web API của trình duyệt, không phải của JS
- khi component dùng setInterval, setTimeout, bất đồng bộ, listener event có thể Unmount thì phải cleanup function để tránh bị memory leak
- ứng dụng của cleanup function là up ảnh làm avatar, tải ảnh từ local lên web,
khi chọn 1 ảnh và dùng luôn thì không nói, khi chọn ảnh thứ 2 để đè lên ảnh thứ nhất, thì dùng cleanup function để xoá ảnh thứ nhất đi
- thứ tự luồng code chạy của component khi dùng useEffect: (https://chat.openai.com/chat/21fabe0e-2136-4722-83d1-add7a97f756d)
    1. cập nhật lại state
    2. cập nhật DOM
    3. render lại UI
    4. gọi cleanup nếu dependency thay đổi
    5. gọi callback useEffect
- useRef(<initValue>) dùng để lưu các giá trị khi component re-render thì các giá trị useRef cũng không bị ảnh hưởng, không bị set lại, hàm useRef sẽ trả về 1 object có key là current
- khi 1 component con nằm trong component cha, khi component cha re-render thì component con sẽ cũng bị re-render theo, điều này là không cần thiết. cách khắc phục điều này là dùng memo    
- memo: là một HOC(higher order component) nhận tham số là 1 component sau đó check các props của component này sau mỗi lần render có bị thay đổi không. Nếu có ít nhất 1 props bị thay đổi giá trị thì sẽ re-render lại component đó còn nếu không có props nào thay đổi thì sẽ không re-render lại component
    --> lần đầu khi component cha được Mount thì component con vẫn được, sau khi Mount thì memo mới bắt đầu check prop
    --> dùng memo thì cần thiết, khi 1 component con không dùng props nào của component cha thì nên dùng meno. nếu component con có dùng props từ component cha thì khỏi cần dùng memo